Base version {

    dash.js v4.3.0; 

}

Modifications {

    Add: [Settings.js] { 
        info: {
            id: null,
            count: null,
            duration: null,
            totalThroughputNeeded: false
        },
    };
    Add: [AbrController.js] AbrController.getSettings();
    Add: [BufferController.js] BufferController.triggerEvent(...) { payload.info = settings.get().info; };
    Add: [ThroughputHistory.js] const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_TOTALTHROUGHPUTNEEDED = 1;
    Add: [ThroughputHistory.js] ThroughputHistory.push(...) { ...
                                    if (settings.get().info.totalThroughputNeeded && $scope !== undefined && $scope.requestList !== undefined && (httpRequest._stream == "video" || httpRequest._stream == "audio")) {
                                        let httpRequestElement = {
                                        "count": settings.get().info.count,
                                        "timeline": httpRequest.mediaStartTime,
                                        "request": httpRequest
                                        };
                                        let searchingEnd = Math.max(0, $scope.requestList.length - 60);
                                        let exist_flag = false;
                                        for (let i = $scope.requestList.length - 1; i >= searchingEnd; i--) {
                                            if ($scope.requestList[i].count == httpRequestElement.count && $scope.requestList[i].timeline == httpRequestElement.timeline) {
                                                $scope.requestList[i] = httpRequestElement;
                                                exist_flag = true;
                                                break;
                                            }
                                        }
                                        if (!exist_flag) {
                                            $scope.requestList.push(httpRequestElement);
                                        }
                                    }
                                ... };
    Add: [ThroughputHistory.js] var appElement = document.querySelector('[ng-controller=DashController]');
                                var $scope = window.angular ? window.angular.element(appElement).scope() : undefined;
    Add: [PlaybackController.js] var appElement = document.querySelector('[ng-controller=DashController]');
                                 var $scope = window.angular ? window.angular.element(appElement).scope() : undefined;                             
    Add: [TimelineConverter.js] var appElement = document.querySelector('[ng-controller=DashController]');
                                var $scope = window.angular ? window.angular.element(appElement).scope() : undefined;
    Add: [DashManifestModel.js] var appElement = document.querySelector('[ng-controller=DashController]');
                                var $scope = window.angular ? window.angular.element(appElement).scope() : undefined;
    Add: [DashManifestModel.js] DashManifestModel.getIsDynamic(manifest) {
                                    if (!isDynamic) {
                                        $scope.targetLatency = 0;
                                        document.getElementById( "target-latency" ).disabled = "true";
                                    }
                                }
    Add: [DashManifestModel.js] DashManifestModel.getMpd(manifest) {
                                    if ($scope !== undefined && $scope.startupTime !== undefined && $scope.startupTimeFormatted !== undefined && $scope.startupTime == 0) {
                                        $scope.startupTime = mpd.availabilityStartTime ? mpd.availabilityStartTime.getTime() / 1000 : null;  // Ignore clientServerTimeShift
                                        $scope.startupTimeFormatted = new Date(parseInt($scope.startupTime * 1000)).toLocaleString();
                                    }
                                }
    Add: [ScheduleController.js] ScheduleController._completeQualityChange(trigger) {
                                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {
                                        mediaType: type,
                                        oldQuality: lastFragmentRequest.quality,
                                        newQuality: item.quality,
                                        streamId: streamInfo.id,
                                        count: settings.get().info.count
                                    });
                                 }


    Change: [PlaybackController.js] PlaybackController.onPlaybackProgression() {  // Consider the situation whatever isDynamic is
                                        if (
                                            //isDynamic &&
                                            _isCatchupEnabled() &&
                                            settings.get().streaming.liveCatchup.playbackRate > 0 &&
                                            !isPaused() &&
                                            !isSeeking()
                                        ) {
                                            if (_needToCatchUp()) {
                                                if ($scope !== undefined && $scope.playerCatchUp !== undefined) {
                                                    $scope.playerCatchUp[settings.get().info.count] = true;
                                                }
                                                startPlaybackCatchUp();
                                            } else {
                                                if ($scope !== undefined && $scope.playerCatchUp !== undefined) {
                                                    $scope.playerCatchUp[settings.get().info.count] = false;
                                                }
                                                stopPlaybackCatchUp();
                                            }
                                        }
                                    };
    Change: [PlaybackController.js] PlaybackController.getCurrentLiveLatency() {  // Change totally with compatibility for non-isDynamic
                                        if (/* !isDynamic ||  */isNaN(availabilityStartTime)) {
                                            return NaN;
                                        }
                                        let currentTime = getNormalizedTime();
                                        if (isNaN(currentTime) || currentTime === 0) {
                                            return 0;
                                        }

                                        if ($scope !== undefined && $scope.normalizedTime !== undefined) {
                                            return Math.max(($scope.normalizedTime - currentTime).toFixed(3), 0);
                                        }
                                        
                                        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;
                                        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);
                                    };
    Change: [PlaybackController.js] PlaybackController.startPlaybackCatchUp() {
                                        if (settings.get().streaming.liveCatchup.maxDrift > 0 && !isLowLatencySeekingInProgress &&
                                            deltaLatency > settings.get().streaming.liveCatchup.maxDrift) {
                                            logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');
                                            isLowLatencySeekingInProgress = true;
                                            if (getIsDynamic()) {
                                                seekToLive();
                                            } else {
                                                seek($scope.normalizedTime, true, false);
                                            }
                                        } else {
                                            isLowLatencySeekingInProgress = false;
                                        }
                                    };
    Change: [ThroughputHistory.js] ThroughputHistory.getSampleSize(...) { ... if (isThroughput) { sampleSize = settings.get().info.totalThroughputNeeded ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_TOTALTHROUGHPUTNEEDED : isLive ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE : AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD; } ... };
    Change: [Settings.js]     function mixinSettings(source, dest, path) {
        for (let n in source) {
            if (source != null && source.hasOwnProperty(n)) {
                if (dest != null && dest.hasOwnProperty(n)) {
                    if (typeof source[n] === 'object' && source[n] !== null) {
                        mixinSettings(source[n], dest[n], path.slice() + n + '.');
                    } else {
                        dest[n] = Utils.clone(source[n]);
                    }
                } else {
                    console.error('Settings parameter ' + path + n + ' is not supported');
                }
            }
        }
    }
    Change: [TimelineConverter.js]  TimelineConverter.setClientTimeOffset(value) {
                                        clientServerTimeShift = value;
                                        if ($scope !== undefined && $scope.clientServerTimeShift !== undefined) {
                                            $scope.clientServerTimeShift = clientServerTimeShift;
                                        }
                                    }
    Change: [DashMetrics.js]  DashMetrics.addHttpRequest(request, responseURL, responseStatus, responseHeaders, traces) {
                                  metricsModel.addHttpRequest(..., request.mediaStartTime);
                              }
    Change: [MetricsModel.js]  MetricsModel.addHttpRequest(mediaType, tcpid, type, url, quality, actualurl, serviceLocation, range, trequest, tresponse, tfinish, responsecode, mediaduration, responseHeaders, traces, mediaStartTime) {
                                   vo.mediaStartTime = mediaStartTime;
                               }
}